<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1</title>
      <link href="/2022/12/01/1/"/>
      <url>/2022/12/01/1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Http和Https之间的区别</title>
      <link href="/2022/11/30/Http%E5%92%8CHttps%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/11/30/Http%E5%92%8CHttps%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="Http和Https之间的区别"><a href="#Http和Https之间的区别" class="headerlink" title="Http和Https之间的区别"></a>Http和Https之间的区别</h3><p>有如下四个不同点：</p><ol><li><strong>安全性</strong>：首先http是没有经过加密的，请求和响应的报文都是明文的，只要有一点http的基础都能看得懂报文里的内容，但是随着现在互联网电商的发展，http协议已经慢慢的变得不安全起来，很容易造成信息的泄露，拦截和攻击，所以这个时候就要在http后面加上s—–&gt;<strong>HTTPS</strong>,这个s代表的是<strong>SSL,TLS</strong>,SSL是TLS的前身，但是绝大部分浏览器都不支持SSL，支持TLS。</li><li><strong>端口号</strong>：首先我们知道http的端口号是80，而如果改成了https那么他的端口号就会变成443</li><li><strong>权重值</strong>：当我们去访问百度或者谷歌的时候，搜索内容的时候，他就会有一个排行，这个排行就是根据权重进行排列，https的权重就会比http的权重高，网站就会优先展示。</li><li><strong>网站的申请流程</strong>：https要去申请CA证书，而https则不需要。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法(第二章)</title>
      <link href="/2022/11/30/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2022/11/30/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>当一个数组中大部分元素为0，或者为同一个值得数组时，可以用稀疏数组来进行压缩储存</p><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><p>1)记录数组<strong>一共有几行几列，有多少个不同</strong>的值</p><p>2)把具有不同值得元素的行列及值记录在一个小规模的数组中，从而<strong>缩小程序</strong>的规模</p><h3 id="实际应用（棋盘上的棋子作为案例）"><a href="#实际应用（棋盘上的棋子作为案例）" class="headerlink" title="实际应用（棋盘上的棋子作为案例）"></a>实际应用（棋盘上的棋子作为案例）</h3><p><img src="http://8.137.11.22/i/2022/11/21/dp5agj-2.png" alt="image-20220928120235935"></p><p><img src="http://8.137.11.22/i/2022/11/21/dppmzq-2.png" alt="image-20220928120633574"></p><h4 id="二维数组转稀疏数组的思路"><a href="#二维数组转稀疏数组的思路" class="headerlink" title="二维数组转稀疏数组的思路"></a>二维数组转稀疏数组的思路</h4><p>1.遍历二维数组中的所有的有效值并统计为一个sum</p><p>2.根据sum可以创建对应的稀疏数组的行 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sparseArr <span class="type">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>3.根据二维数组中的有效数据存入到稀疏数组中,分别对应的是 实际的行减一就是下标不是从0开始区分数学上的行</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先创建一个二维数组,表示棋盘</span></span><br><span class="line">        <span class="comment">//0：表示没有棋子，1表示黑子，2表示篮子</span></span><br><span class="line">        <span class="type">int</span>[][] ChessArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        ChessArray[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        ChessArray[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        ChessArray[<span class="number">5</span>][<span class="number">8</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//原始的二维数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始二维数组&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ints : ChessArray) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二维数组转化为稀疏数组</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 先遍历所有的值，去除大于零和相同的值</span></span><br><span class="line"><span class="comment">         * 将有效值个数用sum来表示</span></span><br><span class="line"><span class="comment">         * 稀疏数组的行数就为sum+1，列为3</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ChessArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ChessArray[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ChessArray[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建对应的稀疏数组</span></span><br><span class="line">        <span class="type">int</span>[][] Spares = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//给稀疏数组赋值</span></span><br><span class="line">        Spares[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        Spares[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        Spares[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">        <span class="comment">//遍历二维数组将非0的数值放入稀疏数组中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ChessArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ChessArray[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ChessArray[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    Spares[count][<span class="number">0</span>] = i;</span><br><span class="line">                    Spares[count][<span class="number">1</span>] = j;</span><br><span class="line">                    Spares[count][<span class="number">2</span>] = ChessArray[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出稀疏数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;得到的稀疏数组为&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] spare : Spares) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : spare) &#123;</span><br><span class="line">                System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="稀疏数组转二位数组思路"><a href="#稀疏数组转二位数组思路" class="headerlink" title="稀疏数组转二位数组思路"></a>稀疏数组转二位数组思路</h4><p>先将稀疏数组的第一行读出来，根据第一行的数据来创建二维数组比如上面的棋盘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [][] ChrreyAarry = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">11</span>][<span class="number">11</span>]</span><br></pre></td></tr></table></figure><p>然后将稀疏数组后的每一行的数据放回到二维数组当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">charreyAarry[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">charreyAarry[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将稀疏数组转化为二位数组</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 先将稀疏数组中的第一行的数据拿出来作为二维数组的行和列</span></span><br><span class="line"><span class="comment">         * 然后将稀疏数组后的每一行的数据放回到二维数组当中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> Spares[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> Spares[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] ChessArray1= <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; Spares.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">Crow</span> <span class="operator">=</span> Spares[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">Ccol</span> <span class="operator">=</span> Spares[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">Val</span> <span class="operator">=</span>Spares[i][<span class="number">2</span>];</span><br><span class="line">            ChessArray1[Crow][Ccol] = Val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后的二维数组&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] ints : ChessArray1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于博客搭建的坑</title>
      <link href="/2022/11/29/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9A%84%E5%9D%91/"/>
      <url>/2022/11/29/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="关于博客搭建的坑"><a href="#关于博客搭建的坑" class="headerlink" title="关于博客搭建的坑"></a>关于博客搭建的坑</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客的搭建很快乐，但是也充满挑战，一个不仔细就会导致整个博客的重来所以我这里整理了我搭建博客以来踩过的坑，可能问题会有的比较杂乱，大家根据自己的问题来看，以此让大家少走弯路争取一次性搭出来。</p><h2 id="初始博客的搭建"><a href="#初始博客的搭建" class="headerlink" title="初始博客的搭建"></a>初始博客的搭建</h2><p>详细教程可以去看水哥教程的几乎讲的很详细了—-&gt;<a href="https://sanshui.vip/jc/">https://sanshui.vip/jc/</a></p><h2 id="node-js的配置"><a href="#node-js的配置" class="headerlink" title="node.js的配置"></a>node.js的配置</h2><p>当你看完node.js配置的时候</p><p><a href="https://www.cnblogs.com/liuqiyun/p/8133904.html%EF%BC%88%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%89">https://www.cnblogs.com/liuqiyun/p/8133904.html（这篇文章）</a></p><p>发现执行<strong>npm install express -g</strong>,报了如下图的错误的时候</p><p><img src="http://8.137.11.22/i/2022/11/29/ngdukd-2.png" alt="image-20221129141821839"></p><p>就将cmd以管理的身份运行即可</p><p>还有一种情况就是当你进入某个文件中使用cmd，执行npm命令的时候还是报错，那么就找到你的node.js文件夹，右键属性—&gt;</p><p><img src="http://8.137.11.22/i/2022/11/30/uhlpfg-2.png" alt="image-20221129142422369"></p><p>高级—-&gt;选中他修改它的权限</p><p><img src="http://8.137.11.22/i/2022/11/29/nl0fjz-2.png" alt="image-20221129142545181"></p><p><img src="http://8.137.11.22/i/2022/11/29/nkr8uq-2.png" alt="image-20221129142521888"></p><p>就能执行后续的命令。</p><h2 id="webstorm的启动"><a href="#webstorm的启动" class="headerlink" title="webstorm的启动"></a>webstorm的启动</h2><p>当在webstorm调用<strong>hexo s</strong>的命令报错的话，你就需要到开发者选项中找到powershell</p><p><img src="http://8.137.11.22/i/2022/11/29/nu3x94-2.png" alt="image-20221129144128444"></p><p>把这个 √  给勾上点击应用，就能在webstorm上启动博客了</p><h2 id="魔改博客的坑"><a href="#魔改博客的坑" class="headerlink" title="魔改博客的坑"></a>魔改博客的坑</h2><p>毕竟如果只是光搭建好了这个博客，效果就只是如下图而已，</p><p><img src="http://8.137.11.22/i/2022/11/29/nxn731-2.png" alt="image-20220801234836437"></p><p>肯定是不能满足广大博主那颗爱美的心</p><p>所以<strong>魔改</strong>就应运而生了，当然要魔改之前肯定是要装上一个新的主题的</p><p>这个主题就是广大博主喜爱的并且好用的butterfly了。</p><p>这是他的官方文档<a href="https://butterfly.js.org/posts/21cfbf15/%EF%BC%88%E6%9C%80%E5%A5%BD%E6%98%AF%E6%A0%B9%E6%8D%AE%E6%96%87%E6%A1%A3%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%9D%A5,%E4%B8%8D%E8%A6%81%E8%B7%B3%E7%9D%80%E7%9C%8B,%E6%8C%89%E9%9C%80%E6%9B%B4%E6%94%B9%EF%BC%89">https://butterfly.js.org/posts/21cfbf15/（最好是根据文档一步一步来,不要跳着看,按需更改）</a></p><p>建议安装的时候用Git安装因为他会直接在你的Hexo 根目录里themes 生成主题文件。这样你找的时候或者魔改的时候也比较方便。不建议用npm安装，通过 npm 安装并不会在 themes 里生成主题文件夹，而是在 node_modules 里生成。</p><h4 id="关于CV别人css样式后有的地方爆红的问题"><a href="#关于CV别人css样式后有的地方爆红的问题" class="headerlink" title="关于CV别人css样式后有的地方爆红的问题"></a><strong>关于CV别人css样式后有的地方爆红的问题</strong></h4><p>爆红可以不用管因为，你可能没有别人的那种样式，但是博客是可以正常打开的，同时后期也可以自己更改</p><h4 id="关于魔改要注意的事情"><a href="#关于魔改要注意的事情" class="headerlink" title="关于魔改要注意的事情"></a><strong>关于魔改要注意的事情</strong></h4><p>首先魔改是有风险的，建议每次在改动后就马上去试试看看有没有效果，如果报错或者没有效果，那么就赶紧还原上一步，并且要记得做好备份，不然你改着改着突然想试试发现报错，这个时候估计你自己可能都不知道是改的那里出了问题，并且在改的时候有的功能是需要装依赖的，不然你开启之后也是会报错的。如下图</p><p><img src="http://8.137.11.22/i/2022/11/29/ulqduj-2.png" alt="image-20221129185047942"></p><p><img src="http://8.137.11.22/i/2022/11/29/um3udp-2.png" alt="image-20221129185110990"></p><p><strong>最后切记切记一定要备份</strong>。</p><h4 id="关于aplayer换歌单的坑"><a href="#关于aplayer换歌单的坑" class="headerlink" title="关于aplayer换歌单的坑"></a>关于aplayer换歌单的坑</h4><p>如果你把别人歌单的id粘过来后发现没有生效，<strong>那么就看看你是不是用的是别人的喜欢的歌，而不是歌单</strong>，因为只有歌单这个插件才能生效</p><p>如下图就是不会生效的</p><p><img src="http://8.137.11.22/i/2022/11/29/upuc8m-2.png" alt="image-20221129185737177"></p><h2 id="关于上传博客的坑"><a href="#关于上传博客的坑" class="headerlink" title="关于上传博客的坑"></a>关于上传博客的坑</h2><p>在魔改完后，相信大家都把博客弄成了自己喜欢的样式，肯定都迫不及待的要上传了，我们就看看上传可能遇到的问题</p><p>当我们装好 hexo-deployer-git 自动部署发布工具    &#x3D;&#x3D;&gt;（npm install hexo-deployer-git –save）安装命令</p><p>当我们执行  git config –global user.name “你GitHub账号的名字”，或者  git config –global user.email “你GitHub账号的邮箱”。</p><p>可能会出现下图的如下情况</p><p><img src="http://8.137.11.22/i/2022/11/29/vq9zfg-2.png" alt="image-20221129191742543"></p><p>这个时候可以找到git的安装目录</p><p><img src="http://8.137.11.22/i/2022/11/29/w3vo47-2.png" alt="image-20221129194130944">打开git-cmd，在输入以上命令，注意要先输入邮箱在输入名字，然后在进行后续的步骤</p><p>注意命令中git config –global user.email 的–global是 <strong>“- -“</strong> 而不是  <strong>—</strong> ,这是两条杠不是一条杠</p><p>不然也会报错</p><p>以上就是我遇到的所以的坑了，希望可以帮助到大家</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法(第一章)</title>
      <link href="/2022/11/28/%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2022/11/28/%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h2><h3 id="度量一个程序-算法-执行时间的两种方法"><a href="#度量一个程序-算法-执行时间的两种方法" class="headerlink" title="度量一个程序(算法)执行时间的两种方法"></a>度量一个程序(算法)执行时间的两种方法</h3><p>事后的统计方法:</p><p>这种方法可行, 但是有两个问题：<strong>一是要想对设计的算法的运行性能进行评测，需要实际运行该程序</strong>；<strong>二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。</strong></p><p>事前估算的方法：</p><p>通过分析某个算法的时间复杂度来判断哪个算法更优.</p><h4 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h4><p>基本介绍</p><p>时间频度：</p><p>一个算法花费的时间与算法中语句的执行次数成正比，那个算法中语句执行的次数多，它花费的时间就多，一个算法中的语句执行次数称为语句频度或者时间频度，记作T(n)。</p><h4 id="举例说明-时间频度"><a href="#举例说明-时间频度" class="headerlink" title="举例说明-时间频度"></a>举例说明-时间频度</h4><p>比如计算1-100所有数字之和，我们设计两种算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i;i&lt;=end;i++)&#123;</span><br><span class="line">total += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里这个语句就执行了100次</span></span><br><span class="line"><span class="comment">//T(n) = n+1;</span></span><br><span class="line"><span class="comment">//直接计算</span></span><br><span class="line">total = (<span class="number">1</span>+end) * end/<span class="number">2</span></span><br><span class="line"><span class="comment">//T(n) = 1;</span></span><br></pre></td></tr></table></figure><h4 id="举例说明-忽略常数项"><a href="#举例说明-忽略常数项" class="headerlink" title="举例说明-忽略常数项"></a>举例说明-忽略常数项</h4><p><img src="http://8.137.11.22/i/2022/11/21/dopisz-2.png" alt="image-20221016091928616"></p><p>结论:</p><ol><li><strong>2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略</strong></li><li><strong>3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略</strong></li></ol><h4 id="举例说明-忽略低次项"><a href="#举例说明-忽略低次项" class="headerlink" title="举例说明-忽略低次项"></a>举例说明-忽略低次项</h4><p><img src="http://8.137.11.22/i/2022/11/21/dp2x9a-2.png" alt="image-20221016092213284"></p><p>结论: </p><ol><li><strong>2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10</strong></li><li><strong>n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20</strong></li></ol><h4 id="举例说明-忽略系数"><a href="#举例说明-忽略系数" class="headerlink" title="举例说明-忽略系数"></a>举例说明-忽略系数</h4><p><img src="http://8.137.11.22/i/2022/11/21/dp395z-2.png" alt="image-20221120213038551"></p><p>结论: </p><ol><li><strong>随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明  这种情况下, 5和3可以忽略。</strong></li><li><strong>而n^3+5n 和 6n^3+4n  ，执行曲线分离，说明多少次方式关键</strong></li></ol><h3 id="时间复杂度的计算方式"><a href="#时间复杂度的计算方式" class="headerlink" title="时间复杂度的计算方式"></a>时间复杂度的计算方式</h3><h4 id="时间复杂度的介绍"><a href="#时间复杂度的介绍" class="headerlink" title="时间复杂度的介绍"></a>时间复杂度的介绍</h4><p>一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，<strong>T(n) &#x2F; f(n) 的极限值为不等于零的常数</strong>，则称f(n)是T(n)的同数量级函数。<strong>记作 T(n)&#x3D;Ｏ( f(n) )，称Ｏ( f(n) )</strong>  为算法的渐进时间复杂度，简称时间复杂度。</p><p><strong>T(n) 不同，但时间复杂度可能相同</strong>。 如：T(n)&#x3D;n²+7n+6 与 T(n)&#x3D;3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。</p><p>计算时间复杂度的方法：</p><p>用常数1代替运行时间中的所有加法常数  T(n)&#x3D;3n²+2n+2  &#x3D;&gt; T(n)&#x3D;3n²+2n+1<br>修改后的运行次数函数中，只保留最高阶项  T(n)&#x3D;3n²+2n+1 &#x3D;&gt; T(n) &#x3D; 3n²<br>去除最高阶项的系数 T(n) &#x3D; 3n² &#x3D;&gt; T(n) &#x3D; n² &#x3D;&gt; O(n²)</p><h4 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h4><p><img src="http://8.137.11.22/i/2022/11/21/dp3pzr-2.png" alt="image-20221016095009793"></p><ol><li>常数阶O(1)</li><li>对数阶O(log2n)</li><li>线性阶O(n)</li><li>线性对数阶O(nlog2n)</li><li>平方阶O(n^2)</li><li>立方阶O(n^3)</li><li>k次方阶O(n^k)</li><li>指数阶O(2^n)</li></ol><p>说明：</p><ol><li>常见的算法时间复杂度由小到大依次为：<strong>Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n)</strong> ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低</li><li>从图中可见，我们应该尽可能避免使用指数阶的算法</li></ol><h4 id="时间复杂度的举例说明（常见）"><a href="#时间复杂度的举例说明（常见）" class="headerlink" title="时间复杂度的举例说明（常见）"></a>时间复杂度的举例说明（常见）</h4><h5 id="常数阶O-1"><a href="#常数阶O-1" class="headerlink" title="常数阶O(1)"></a>常数阶O(1)</h5><p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span>  <span class="operator">=</span> i+j;</span><br><span class="line"><span class="comment">//这里的代码不管i,j是多少他都执行一次所以这里的时间复杂度就为o</span></span><br></pre></td></tr></table></figure><h5 id="对数阶O-log2n"><a href="#对数阶O-log2n" class="headerlink" title="对数阶O(log2n)"></a>对数阶O(log2n)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n)  。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) </span></span><br></pre></td></tr></table></figure><h5 id="线性复杂度O-n"><a href="#线性复杂度O-n" class="headerlink" title="线性复杂度O(n)"></a>线性复杂度O(n)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;=n;++i)&#123;</span><br><span class="line">j=i;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度</span></span><br></pre></td></tr></table></figure><h5 id="平方阶O-n²"><a href="#平方阶O-n²" class="headerlink" title="平方阶O(n²)"></a>平方阶O(n²)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j =<span class="number">1</span>; j&lt;=i; j++)&#123;</span><br><span class="line">j=i;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即  O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m*n)</span></span><br></pre></td></tr></table></figure><h4 id="线性阶对数阶-n-log-N"><a href="#线性阶对数阶-n-log-N" class="headerlink" title="线性阶对数阶(n log N)"></a>线性阶对数阶(n log N)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">1</span>;m&lt;n;m++)&#123;</span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">i = i*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)</span></span><br></pre></td></tr></table></figure><h3 id="平均时间复杂度和最坏时间复杂度"><a href="#平均时间复杂度和最坏时间复杂度" class="headerlink" title="平均时间复杂度和最坏时间复杂度"></a>平均时间复杂度和最坏时间复杂度</h3><ol><li>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。</li><li>最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。</li><li>平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。</li></ol><p><img src="http://8.137.11.22/i/2022/11/21/dp549g-2.png" alt="image-20221016100219172"></p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。</li><li>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况</li><li>在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给各位朋友的一封信</title>
      <link href="/2022/11/27/idnex/"/>
      <url>/2022/11/27/idnex/</url>
      
        <content type="html"><![CDATA[<p>互联网的精神在于开发和共享，但这并不意味着就能够随意窃取我的劳动成果。本站的所有文章是我一个字一个字用心敲下来的，网站的运营只有我一个人，付出了我自己大量的精力希望看官老爷给一个免费的关注，你们的关注是我更新的最大动力。</p><p>我会坚持每周更新一篇文章我把文章分为两大板块一个是看官老爷必看内容另一个是往期优质内容推广在必看内容是简述博客的用途。在往期优质内容中我会找一些资源来进行分享和转发一些优质内容提供大家来学习也提高自己的能力我会把原作者标注出来(转载链接)同时也欢迎大家积极投稿营造绿色、安全的网络环境。</p><p>不管未来生活有多忙，生活会遇到怎么样的改变与挑战，我都会以一个匠人的心态去经营这个博客未来的道路大家一起努力。</p><p>未经本人同意擅自窃取我的劳动成果，违法必究。</p>]]></content>
      
      
      <categories>
          
          <category> 必看内容 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>我</p><p>常用昵称是：小新</p><p>一个热爱编程的大学生</p><p>热爱探索，正是对一切新鲜的事物感到好奇</p><p>于是便有了这个博客</p><p>目标是成为一名优秀的程序员</p><p>每天进步一点点</p><hr><p>基础信息</p><p>微信：1124655410</p><p>博客：（暂无域名）</p><p>GitHub:<a href="https://github.com/aiaicoder">https://github.com/aiaicoder</a></p><p>邮箱：<a href="mailto:&#x31;&#x35;&#55;&#x31;&#x32;&#48;&#56;&#50;&#54;&#48;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#x6d;">&#x31;&#x35;&#55;&#x31;&#x32;&#48;&#56;&#50;&#54;&#48;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#x6d;</a></p><hr><p>认认真真过好每一天，做好每一件事情</p><p>打败我们的不是别人，而是贪玩的自己</p><p>不负年华，不负你</p><hr><p>免责声明<br>本站以分享互联网经验、学习知识为目的，所有文章所涉及使用的工具、资源等均来自互联网， 仅供学习和研究使用，版权归作者所有，如果无意之中侵犯了您的版权，请来信告知。本站将在第一时间删除！另外， 本站内的文章多为博主原创，大部分是由CSDN平台搬迁过来，仅供学习交流之用，不参与商业用途。</p><p>遵守相关法律法规，由于本站资源部分来源于网络，开发也是使用开源模板，故无法核实资源侵权的真实性，无论出于何种目的要求本站删除内容，“您”均需要提供相关证明，否则不予处理。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/comments/index.html"/>
      <url>/comments/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/title.js"/>
      <url>/js/title.js</url>
      
        <content type="html"><![CDATA[//动态标题var OriginTitile = document.title;var titleTime;document.addEventListener("visibilitychange", function () {    if (document.hidden) {        //离开当前页面时标签显示内容        document.title = "w(ﾟДﾟ)w 不要走！再看看嘛！";        clearTimeout(titleTime);    } else {        //返回当前页面时标签显示内容        document.title = "♪(^∇^*)欢迎肥来！" + OriginTitile;        //两秒后变回正常标题        titleTime = setTimeout(function () {            document.title = OriginTitile;        }, 2000);    }});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-ceQYJiVx" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5092779494" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="400px" data-preload="none" data-theme="#ad7a86"    ></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 阿里矢量图标库 */svg.icon {    width: 1.2rem;    height: 1.2rem;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15rem;    fill: currentColor;    overflow: hidden;}/* 头图透明 */#page-header {    background: transparent !important;    /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */}#page-header .post-bg:before {    background-color: transparent !important;}#footer {    background: transparent !important;}#footer #footer-wrap {    color: #000;}#footer #footer-wrap a {    color: #000;}#nav #nav-group {    max-width: 1200px;    width: 100%;    display: flex;    margin-left: auto;    margin-right: auto;    /* 搜索与黑夜切换样式 */    /* 元素布局 */    /* 横向排布子菜单 */}#nav #nav-group #search-button {    display: inline;    padding: 0 0 0 0.5rem;    position: relative;    padding-bottom: 0.3rem;    text-shadow: 0.05rem 0.05rem 0.1rem #000;    font-size: 0.78em;    cursor: pointer;}#nav #nav-group #darkmodeBt {    display: inline;    padding: 0 0 0 0.5rem;    position: relative;    padding-bottom: 0.3rem;    text-shadow: 0.05rem 0.05rem 0.1rem #000;    font-size: 0.78em;    cursor: pointer;}#nav #nav-group #toggle-menu {    padding: 0.1rem 0 0 0.5rem;}#nav #nav-group #blog_name {    box-flex: 0.5;    flex: 0.5;}#nav #nav-group #blog_name a#site-name {    font-family: 'aqqxs', sans-serif;    font-size: 18px;}#nav #nav-group #navFn {    text-align: right;    box-flex: 0.5;    flex: 0.5;}#nav #nav-group #navFn span {    font-family: 'aqqxs', sans-serif;    font-size: 14px;}#nav #nav-group .menus_items span {    font-family: 'aqqxs', sans-serif;    font-size: 16px;}#nav #nav-group .menus_items .menus_item .menus_item_child {    border-radius: 0.625rem;}#nav #nav-group .menus_items .menus_item .menus_item_child li {    display: inline-block;}#nav #nav-group .menus_items .menus_item .menus_item_child li:hover {    background-color: #5bf;    border-radius: 0.625rem;}#nav.hide-menu #darkmodeBt span {    display: none !important;}article.writeByhand {    font-family: 'writeByhand', sans-serif;    font-size: large;}#sidebar #sidebar-menus {    background: linear-gradient(60deg, #ffd7e4 0%, #c8f1ff 100%);    font-family: 'aqqxs', sans-serif;    /* 手机侧栏菜单展开 信息、头像位置调整*/    /* 手机侧栏菜单展开 follow_me按钮*/    /* 手机侧栏菜单展开 社交图标 */}#sidebar #sidebar-menus .site-data {    margin-top: 0.5rem;    /* 分类等字体加粗 */}#sidebar #sidebar-menus .site-data .headline {    font-size: 0.875rem;}#sidebar #sidebar-menus .site-data .length-num {    font-size: 0.8rem !important;}#sidebar #sidebar-menus #sidebar-avatar {    margin-top: 0.2rem;    /* 作者名 */}#sidebar #sidebar-menus #sidebar-avatar .author-info__name {    font-weight: 500;    font-size: 1.57em;}#sidebar #sidebar-menus #sidebar-avatar .avatar-img img {    width: 110px;    height: 110px;    border-radius: 70px;    transition: all 0.5s;}#sidebar #sidebar-menus #card-info-btn {    display: block;    margin: 0.3rem 1rem 0 1rem;    background-color: var(--btn-bg);    color: var(--btn-color);    text-align: center;    line-height: 2.4;    overflow: hidden;    border-radius: 0.625rem;}#sidebar #sidebar-menus .menu-info-social-icons {    margin: 0.5rem 0 0 0;}#sidebar #sidebar-menus .menu-info-social-icons .social-icon {    display: inline;    padding: 0 0.7rem 0 0.7rem;}#sidebar #sidebar-menus .simply-cha-top {    margin: 0 0 -3rem 0;    height: 4rem;    background: url("/img/simplycha-top.webp");    background-size: contain;    background-repeat: no-repeat;    background-position: 100% 0%;}#sidebar #sidebar-menus .simply-cha {    margin-top: -4rem;    height: 5rem;    background: url("/img/simplycha.webp");    background-size: contain;    background-repeat: no-repeat;}#sidebar #sidebar-menus .fas.fa-chevron-down.expand {    display: none;}#site-title,#subtitle {    font-family: 'aqqxs', sans-serif;}#site_social_icons {    display: none !important;}#post-comment .comment-head {    margin: 1rem;}[data-theme="dark"] #footer #footer-wrap {    color: #fff;}[data-theme="dark"] #footer #footer-wrap a {    color: #fff;}[data-theme="dark"] #footer:before {    background: transparent !important;}[data-theme="dark"] #page-header:before {    background: transparent !important;}[data-theme="dark"] #nav .menus_items .menus_item .menus_item_child li:hover {    background-color: #2298e7;    border-radius: 0.625rem;}[data-theme="dark"] #sidebar #sidebar-menus {    background: linear-gradient(60deg, #2c0c16 0%, #043749 100%);}/* 存在手机侧栏菜单时，隐藏下侧内容（即侧边栏（900以上出现的bug不怎么影响了 */@media screen and (max-width: 900px) {    #aside-content {        display: none;    }}/* 字体样式引入 */@font-face {    font-family: 'aqqxs';    src: url("https://cdn1.tianli0.top/gh/2x-ercha/cdn-for-try/fonts/FXAiQingQiXiangSuo.ttf");    ont-display: swap;}@font-face {    font-family: 'writeByhand';    src: url("./font/WoZaiXingYeShenChuDengNi.ttf");    ont-display: swap;}.tag.link {    display: flex;    padding: 0.5em;}]]></content>
      
    </entry>
    
    
  
</search>
